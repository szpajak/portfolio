<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Klaudiusz Grobelski, Szymon Pająk">

<title>Badania Operacyjne - Algorytm</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    <img src="./Grafiki/pl_logo.jpg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Badania Operacyjne</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./Model zagadnienia.html" rel="" target="">
 <span class="menu-text">Model zagadnienia</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./Algorytm.html" rel="" target="" aria-current="page">
 <span class="menu-text">Algorytm</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Aplikacja.html" rel="" target="">
 <span class="menu-text">Aplikacja</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Testy.html" rel="" target="">
 <span class="menu-text">Testy</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Podsumowanie.html" rel="" target="">
 <span class="menu-text">Podsumowanie</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Algorytm</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Klaudiusz Grobelski, Szymon Pająk </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="pseudokod" class="level2">
<h2 class="anchored" data-anchor-id="pseudokod">Pseudokod</h2>
<p>Algorytm ewolucyjny przeszukuje przestrzeń rozwiązań problemu w celu wyszukania najlepszego rozwiązania. Sposób działania algorytmu wzorowany jest na ewolucji biologicznej.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Grafiki/pseudokod.jpg" class="img-fluid figure-img" width="450"></p>
<figcaption class="figure-caption">Pseudokod algorytmu genetycznego</figcaption>
</figure>
</div>
</section>
<section id="elementy-algorytmu-ewolucyjnego" class="level2">
<h2 class="anchored" data-anchor-id="elementy-algorytmu-ewolucyjnego">Elementy algorytmu ewolucyjnego</h2>
<ol type="1">
<li><p>Metoda kodowania</p></li>
<li><p>Metoda inicjalizacji populacji początkowej</p></li>
<li><p>Metoda selekcji</p></li>
<li><p>Krzyżowanie</p></li>
<li><p>Mutacja</p></li>
<li><p>Parametry sterujące pracą algorytmu</p></li>
</ol>
</section>
<section id="metoda-kodowania" class="level2">
<h2 class="anchored" data-anchor-id="metoda-kodowania">1. Metoda kodowania</h2>
<ul>
<li>Wariant ułożenia genów: klasyczny</li>
<li>Genotyp w postaci macierzy zespołów o wymiarze 20x20.</li>
<li>Wartości przechowywane w genach są obiektami klasy “Match”.</li>
<li>Każdy gen (obiekt) zawiera wszystkie parametry danego meczu tj.:
<ul>
<li>Drużyna nr 1 (gospodarz)</li>
<li>Drużyna nr 2 (gość)</li>
<li>Godzina</li>
<li>Kolejka</li>
<li>Stadion</li>
<li>“Koszt” danego meczu</li>
</ul></li>
</ul>
</section>
<section id="metoda-inicjalizacji-populacji-początkowej" class="level2">
<h2 class="anchored" data-anchor-id="metoda-inicjalizacji-populacji-początkowej">2. Metoda inicjalizacji populacji początkowej</h2>
<p>Inicjalizacja populacji początkowej odbywa się w sposób losowy. W praktyce oznacza to generowanie populacji rozwiązań początkowych zgodnie z rozkładem równomiernym, przy uwzględnieniu ograniczeń.</p>
</section>
<section id="metoda-selekcji" class="level2">
<h2 class="anchored" data-anchor-id="metoda-selekcji">3. Metoda selekcji</h2>
<p>W naszym algorytmie zaimplementowaliśmy dwie metody wyboru nowej populacji. W każdej z metod przewidziano możliwość uwzględnienia elity (pojęcie rozwinięte poniżej).</p>
<p><strong>Selekcja rankingowa</strong></p>
<p>Wybór osobników do kolejnej generacji dokonywany jest na podstawie rankingu utworzonego na bazie wartości funkcji kosztu każdego meczu. Osobniki na wyższych miejscach mają większą szansę na zostanie rodzicami nowej generacji. Parametry rankingu ustalane sa przez uzytkownika.</p>
<p><strong>Selekcja turniejowa</strong></p>
<p>Z populacji wybiera się ilość osobników (tzw. rozmiar turnieju, która kwalifikuje się do zawodów). Następnie dwa najlepsze osobniki są wybierane jako rodzice dla nowego osobnika. Rozmiar turnieju jest stały dla każdej instancji testowej, jednak jego dobór jest losowy.</p>
<p><strong>Elita</strong></p>
<p>Parametr podawany jest w postaci procentów. Oznacza jaki odsetek najlepszych rodziców z poprzedniej generacji może przejść do kolejnej. Jest to możliwość, a nie wymóg, zatem jeśli żaden rodzic nie okaże się dostatecznie dobry to po prostu nastąpi całkowita zmiana.</p>
</section>
<section id="krzyżowanie" class="level2">
<h2 class="anchored" data-anchor-id="krzyżowanie">4. Krzyżowanie</h2>
<p>Kolejnym ważnym etapem algorytmu jest etap mutacji oraz krzyżowania. Operacja krzyżowania rozumiemy analogicznie do rozmnażania osobników w przyrodzie, oznacza to że nowo utworzony potomek otrzyma losową kombinację genów od dwóch rodziców, dla naszego algorytmu operacja krzyżowania wygląda następująco. Wybieramy jeden z rodzajów selekcji, która wybiera dwóch rodziców, w kolejnym kroku wybieramy mecze z pierwszej części sezonu pierwszego rodzica, natomiast od drugiego rodzica z drugiej części sezonu, analogicznie tworzymy drugiego potomka, z tą różnicą że odwrotnie wybieramy pierwszą oraz drugą część sezonu. Następnie przechodzimy do operacji mutacji, która polega na zróżnicowaniu osobników, jest stosowana dla kilku losowych osobników populacji. Dzięki mutacjom otrzymujemy duża różnorodność rozwiązań, jednak powoduje to również zepsucie dobrego rozwiązania. Mutacje mogą polegać na:</p>
<ol type="1">
<li><p>zmianie wartości losowo wybranego genu</p></li>
<li><p>zmianie kilku losowo wybranych genów</p></li>
<li><p>przesunięciu genów</p></li>
<li><p>operacji inwersji</p></li>
<li><p>operacji tasującej, czyli zmianie położeń genów</p></li>
</ol>
</section>
<section id="mutacja" class="level2">
<h2 class="anchored" data-anchor-id="mutacja">5. Mutacja</h2>
<p><strong>Zmiana gospodarza</strong></p>
<p>Polega ona na wybraniu danego odsetka meczów (podanego poprzez parametr “Stopień mutacji”) z terminarza, a następnie w każdym z nich zamianie gospodarza z gościem. Aby uniknąć błędów w terminie meczu rewanżowego drużyny są również zmieniane. Zatem zmiany zachodzą parami.</p>
<p><strong>Zmiana kolejki</strong></p>
<p>Polega ona na wybraniu danego odsetka par meczów (podanego poprzez parametr “Stopień mutacji”) z terminarza, a następnie zamianie między nimi kolejek. Dokonywanie zmian parami pozwala uniknąć błędów.</p>
<p><strong>Zmiana godzin w 1. części sezonu</strong></p>
<p>Polega ona na wybraniu danego odsetka par meczów (podanego poprzez parametr “Stopień mutacji”) z terminarza w pierwszej części sezonu, a następnie zamianie między nimi godzin. Zmiany dokonywane są parami, a oba mecze są w obrębie jednej kolejki. Pozwala to uniknąć potencjalnych błędów.</p>
<p><strong>Zmiana godzin w 2. części sezonu</strong></p>
<p>Mutacja bardzo zbliżona do powyższej. Polega ona na wybraniu danego odsetka par meczów (podanego poprzez parametr “Stopień mutacji”) z terminarza w drugiej części sezonu, a następnie zamianie między nimi godzin. Zmiany dokonywane są parami, a oba mecze są w obrębie jednej kolejki. Pozwala to uniknąć potencjalnych błędów.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>