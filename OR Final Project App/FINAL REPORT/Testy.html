<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Klaudiusz Grobelski, Szymon Pająk">

<title>Badania Operacyjne - Testy</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="./index.html" class="navbar-brand navbar-brand-logo">
    <img src="./Grafiki/pl_logo.jpg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Badania Operacyjne</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./Model zagadnienia.html" rel="" target="">
 <span class="menu-text">Model zagadnienia</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Algorytm.html" rel="" target="">
 <span class="menu-text">Algorytm</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Aplikacja.html" rel="" target="">
 <span class="menu-text">Aplikacja</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./Testy.html" rel="" target="" aria-current="page">
 <span class="menu-text">Testy</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./Podsumowanie.html" rel="" target="">
 <span class="menu-text">Podsumowanie</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Testy</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Klaudiusz Grobelski, Szymon Pająk </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="scenariusze-testów" class="level2">
<h2 class="anchored" data-anchor-id="scenariusze-testów">Scenariusze testów</h2>
<p>Pierwszym etapem testów, było sprawdzenie poprawności zaimplementowanego algorytmu. Nasze testy rozpoczeliśmy od mniejszej ilości zespołów, a następnie sprawdzaliśmy poprawność działania. Celem takiego działania było sprawdzenie czy algorytm zachowuje się poprawnie dla prostszego problemu, który był dla nas łatwiejszy do analizy. W kolejnym kroku zajeliśmy się testowanie poszczególnych funkcji juz dla naszego problemu, każdą funkcję testowaliśmy po jej implementacji w sposób ręczny, to znaczy sprawdzaliśmy czy dana funkcja zachowuje się tak jak zaplanowaliśmy, dzięki temu szybko mogliśmy wyeliminować błędy oraz sprawdzić poprawność algorytmu. W ostatniej części zajeliśmy się napisaniem kilku unit testów w Pythonie, które jeszcze raz miały za zadanie sprawdzić czy dane funkcję zachowują się prawidłowo.</p>
</section>
<section id="metodyka-badań-i-testy" class="level2">
<h2 class="anchored" data-anchor-id="metodyka-badań-i-testy">Metodyka badań i testy</h2>
<p>W naszych badaniach nad algorytmem sprawdzimy jak poszczególne parametry wpływają na wynik końcowy.</p>
<p><strong>Test 1</strong></p>
<p>Autor: Klaudiusz Grobelski</p>
<p>Pierwszym z nich będzie rozmiar populacji początkowej, dla czterech różnych wielkości populacji początkowych sprawdzimy zachowanie się algorytmu. Dla wszystkich zastosujemy:</p>
<ul>
<li><p>rozmiar pokolenia 30,</p></li>
<li><p>selekcję turniejową,</p></li>
<li><p>wielkość turnieju 10,</p></li>
<li><p>procent elity 5%,</p></li>
<li><p>rodzaj mutacji zmiana gospodarza,</p></li>
<li><p>procentowa ilość mutacji 10%,</p></li>
<li><p>stopień mutacji 10,</p></li>
</ul>
<p>Otrzymane wyniki:</p>
<ul>
<li><p>wielkość populacji początkowej 20</p>
<ul>
<li>Funkcja celu 128138,76</li>
</ul>
<p><img src="images/1-01.png" class="img-fluid" width="554"></p></li>
<li><p>wielkość populacji początkowej 40</p>
<ul>
<li>Funkcja celu 183101,45</li>
</ul>
<p><img src="images/2.png" class="img-fluid" width="540"></p></li>
<li><p>wielkość populacji początkowej 60</p>
<ul>
<li>Funkcja celu 169624,29</li>
</ul>
<p><img src="images/3.png" class="img-fluid" width="540"></p></li>
<li><p>wielkość populacji początkowej 80</p>
<ul>
<li>Funkcja celu 227747,8</li>
</ul>
<p><img src="images/4.png" class="img-fluid" width="540"></p></li>
</ul>
<p>Wnioski: Wielkość populacji wpływa na wynik czym jest ona większa tym funkcja celu znajduję większy wynik</p>
<p><strong>Test 2</strong></p>
<p>Autor: Klaudiusz Grobelski</p>
<p>Drugim badanym parametrem będzie rozmiar pokolenia, również przetestujemy dla czterech różnych rozmiarów. Dla wszystkich zastosujemy:</p>
<ul>
<li><p>rozmiar populacji poczatkowej 40</p></li>
<li><p>selekcję turniejową,</p></li>
<li><p>wielkość turnieju 10,</p></li>
<li><p>procent elity 5%,</p></li>
<li><p>rodzaj mutacji zmiana gospodarza,</p></li>
<li><p>procentowa ilość mutacji 10%,</p></li>
<li><p>stopień mutacji 10%,</p></li>
</ul>
<p>Otrzymane wyniki:</p>
<ul>
<li><p>wielkość pokolenia 10</p>
<ul>
<li>Funkcja celu 159480,86</li>
</ul>
<p><img src="images/5.png" class="img-fluid" width="540"></p></li>
<li><p>wielkość pokolenia 30</p>
<ul>
<li>Funkcja celu 152456,27</li>
</ul>
<p><img src="images/6.png" class="img-fluid" width="540"></p></li>
<li><p>wielkość pokolenia 50</p>
<ul>
<li>Funkcja celu 166339,8</li>
</ul>
<p><img src="images/7.png" class="img-fluid" width="540"></p></li>
<li><p>wielkość pokolenia 70</p>
<ul>
<li>Funkcja celu 152625,78</li>
</ul>
<p><img src="images/8.png" class="img-fluid" width="540"></p></li>
</ul>
<p>Wnioski: Rozmiar pokolenia ma znaczenie na działanie algorytmu, dzięki większej ilości algorytm może zbadać więcej możliwych rozwiązań.</p>
<p><strong>Test 3</strong></p>
<p>Autor: Klaudiusz Grobelski</p>
<p>Kolejnym parametrem będzie badanie rodzaju selekcji. Dla pozostałych parametrów zastosujemy poszczególne wartości:</p>
<ul>
<li><p>rozmiar populacji poczatkowej 40</p></li>
<li><p>rozmiar pokolenia 30,</p></li>
<li><p>wielkość turnieju 10,</p></li>
<li><p>procent elity 5%,</p></li>
<li><p>rodzaj mutacji zmiana gospodarza,</p></li>
<li><p>procentowa ilość mutacji 10%,</p></li>
<li><p>stopień mutacji 10%,</p></li>
</ul>
<p>Otrzymane wyniki:</p>
<ul>
<li><p>selekcja turniejowa</p>
<ul>
<li>Funkcja celu 150496,82</li>
</ul>
<p><img src="images/9-01.png" class="img-fluid" width="540"></p></li>
<li><p>selekcja rankingowa</p>
<ul>
<li>Funkcja celu 162395,48</li>
</ul>
<p><img src="images/10.png" class="img-fluid" width="540"></p></li>
</ul>
<p>Wnioski: Selekcja truniejowa oraz rankingowa dobrze znajdują maksimum, żadna z metod nie jest znacząco lepsza od drugiej.</p>
<p><strong>Test 4</strong></p>
<p>Autor: Klaudiusz Grobelski</p>
<p>Następnie przejdziemy do testowania wielkości turnieju oraz rankingu. Zastosujemy poniższe parametry:</p>
<ul>
<li><p>rozmiar populacji poczatkowej (40 mozna zmienic i najlepiej by bylo zeby zawsze byla taka sama wiec nie wiem czy przez gui to pojdzie i nie trzeba bedzie recznie tego zrobic),</p></li>
<li><p>rozmiar pokolenia 30, (można zmienic)</p></li>
<li><p>selekcję turniejową oraz rankingową</p></li>
<li><p>procent elity 5%,</p></li>
<li><p>rodzaj mutacji zmiana gospodarza,</p></li>
<li><p>procentowa ilość mutacji 10%,</p></li>
<li><p>stopień mutacji 10%,</p></li>
</ul>
<p>Otrzymane wyniki:</p>
<ul>
<li><p>selekcja turniejowa</p>
<ul>
<li><p>rozmiar turnieju 5</p>
<ul>
<li>Funkcja celu 149361,12</li>
</ul>
<p><img src="images/11-02.png" class="img-fluid" width="540"></p></li>
</ul>
<!-- -->
<ul>
<li><p>rozmiar turnieju 10</p>
<ul>
<li>Funkcja celu 174147,93</li>
</ul>
<p><img src="images/12-02.png" class="img-fluid" width="540"></p></li>
<li><p>rozmiar turnieju 20</p>
<ul>
<li>Funkcja celu 163348,26</li>
</ul>
<p><img src="images/13-01.png" class="img-fluid" width="540"></p></li>
</ul></li>
</ul>
<p>Wnioski: Wielkość turnieju ma znaczenie, dla działania algorytmu natomiast zbyt duży turniej powoduje, że zostają też krzyżowane juz znaczenie słabsze gatunki z wybranego pokolenia, co powoduje mniejsze poprawienie funkcji celu.</p>
<ul>
<li><p>selekcja rankingowa</p>
<ul>
<li><p>rozmiar rankingu 5</p>
<ul>
<li>Funkcja celu 153323,84</li>
</ul>
<p><img src="images/14.png" class="img-fluid" width="540"></p></li>
<li><p>rozmiar rankingu 10</p>
<ul>
<li>Funkcja celu 150997,04</li>
</ul>
<p><img src="images/15.png" class="img-fluid" width="540"></p></li>
<li><p>rozmiar rankingu 20</p>
<ul>
<li>Funkcja celu 171588,25</li>
</ul>
<p><img src="images/16.png" class="img-fluid" width="540"></p></li>
</ul></li>
</ul>
<p>Wnioski: Dla selekcji rankingowej im większa wielkość rankingu tym lepszy wynik znajduje algorytm.</p>
<p><strong>Test 5</strong></p>
<p>Autor: Szymon Pająk</p>
<p>Kolejnym parametrem do testów jest procentowa ilość elity w pokoleniu, sprawdzimy dla trzech różnych wartości. Pozostałe parametry wyglądają następująco:</p>
<ul>
<li><p><u>rozmiar populacji poczatkowej</u>: 40,</p></li>
<li><p><u>rozmiar pokolenia</u>: 30,</p></li>
<li><p><u>selekcja turniejowa</u></p></li>
<li><p><u>wielkość turnieju</u>: 10,</p></li>
<li><p><u>rodzaj mutacji</u>: zmiana gospodarza,</p></li>
<li><p><u>procentowa ilość mutacji</u>: 10%,</p></li>
<li><p><u>stopień mutacji</u>: 10%,</p></li>
</ul>
<p>Otrzymane wykresy:</p>
<ul>
<li><p>Elita: 10%</p>
<ul>
<li><p>Funkcja celu: 147900.8</p>
<p><img src="images/Zrzut ekranu 2024-01-06 172018.png" class="img-fluid" width="554"></p></li>
</ul></li>
<li><p>Elita: 20%</p>
<ul>
<li><p>Funkcja celu: 161188.74</p>
<p><img src="images/Zrzut ekranu 2024-01-06 172208.png" class="img-fluid" width="554"></p></li>
</ul></li>
<li><p>Elita: 50%</p>
<ul>
<li><p>Funkcja celu: 216706.32</p>
<p><img src="images/Zrzut ekranu 2024-01-06 172300.png" class="img-fluid" width="554"></p></li>
</ul></li>
</ul>
<p>Wniosek: Większy odsetek elity pozytywnie wpływa na działanie algorytmu. Jest tak, ponieważ najlepsze osobniki mają szansę przetrwać więcej niż jedno pokolenie.</p>
<p><strong>Test 6</strong></p>
<p>Autor: Szymon Pająk</p>
<p>Następnie sprawdzimy jak wybór poszczególnych mutacji oraz ich połączeń daje najlepszy wynik końcowy. Pozostałe parametry wyglądają następująco:</p>
<ul>
<li><p><u>rozmiar populacji poczatkowej</u>: 40,</p></li>
<li><p><u>rozmiar pokolenia</u>: 30,</p></li>
<li><p><u>selekcja turniejowa</u></p></li>
<li><p><u>wielkość turnieju</u>: 10,</p></li>
<li><p><u>procent elity</u>: 5%,</p></li>
<li><p><u>procentowa ilość mutacji</u>: 10%,</p></li>
<li><p><u>stopień mutacji</u>: 10%,</p></li>
</ul>
<p>Otrzymane wykresy:</p>
<ul>
<li><p>Zmiana godziny</p>
<ul>
<li><p>Funkcja celu: 178017.71</p>
<p><img src="images/Zrzut ekranu 2024-01-06 193858.png" class="img-fluid" width="554"></p></li>
</ul></li>
<li><p>Zmiana kolejki</p>
<ul>
<li><p>Funkcja celu: 167399.82</p>
<p><img src="images/Zrzut ekranu 2024-01-06 194156.png" class="img-fluid" width="554"></p></li>
</ul></li>
<li><p>Zmiana godziny 1. część sezonu</p>
<ul>
<li><p>Funkcja celu: 141450.49</p>
<p><img src="images/Zrzut ekranu 2024-01-06 193936.png" class="img-fluid" width="554"></p></li>
</ul></li>
<li><p>Zmiana godziny 2. część sezonu</p>
<ul>
<li><p>Funkcja celu: 135657.01</p>
<p><img src="images/Zrzut ekranu 2024-01-06 194041.png" class="img-fluid" width="554"></p></li>
</ul></li>
<li><p>Zmiana godziny oraz zmiana kolejki</p>
<ul>
<li><p>Funkcja celu: 193558.93</p>
<p><img src="images/Zrzut ekranu 2024-01-06 194842.png" class="img-fluid" width="554"></p></li>
</ul></li>
<li><p>Zmiana godziny 1. część sezonu oraz zmiana godziny 2. część sezonu</p>
<ul>
<li><p>Funkcja celu: 153268.18</p>
<p><img src="images/Zrzut ekranu 2024-01-06 195325.png" class="img-fluid" width="554"></p></li>
</ul></li>
<li><p>Zmiana godziny, zmiana kolejki, zmiana godziny 1. część sezonu oraz zmiana godziny 2. część sezonu</p>
<ul>
<li><p>Funkcja celu: 175136.87</p>
<p><img src="images/Zrzut ekranu 2024-01-06 195910.png" class="img-fluid" width="554"></p></li>
</ul></li>
</ul>
<p>Wniosek: Przy stosowaniu tylko jednego rodzaju mutacji najlepszym rozwiązaniem będzie zamiana gospodarza meczu. Kolejnym dobrym, lecz nieco gorszym rozwiązaniem będzie zmiana kolejki. Najsłabiej wypadają zmiany godziny rozgrywania meczów wewnątrz danej kolejki. Zgodnie z oczekiwaniem zmiana w 1. części sezonu daje zbliżone efekty do zmiany w 2. części sezonu. Jeśli chodzi o stosowanie mutacji parami to po tym co zostało zaobserwowane w przypadku stosowania pojedynczych mutacji, zgodnie z tym czego się spodziewaliśmy kombinacja zmiany godziny i zmiany kolejki okazała się lepsza. Dodatkowo zaobserwowano, że zmienianie godzin w obu częściach sezonu sprawia, że funkcja celu z biegiem iteracji osiąga coraz mniejsze wartości. Zastosowanie wszystkich czterech rodzajów mutacji sprawiło, że funkcja celu osiągnęła wartość pomiędzy tą osiągniętą w przypadku zmiany gospodarza i kolejki oraz godzin w obu częściach sezonu. Optymalne zatem jest stosowanie dwóch rodzajów mutacji: zmiany gospodarza oraz zmiany kolejki.</p>
<p><strong>Test 7</strong></p>
<p>Autor: Szymon Pająk</p>
<p>Przedostatnim testowanym parametrem będzie, sprawdzenie jakie znaczenie ma procentowa ilość mutacji na znalezienie maksimum. Dla wszystkich parametrów zastosujemy:</p>
<ul>
<li><p><u>rozmiar populacji poczatkowej</u>: 40,</p></li>
<li><p><u>rozmiar pokolenia</u>: 30,</p></li>
<li><p><u>selekcja turniejowa</u></p></li>
<li><p><u>wielkość turnieju</u>: 10,</p></li>
<li><p><u>procent elity</u>: 5%,</p></li>
<li><p><u>rodzaj mutacji</u>: zmiana gospodarza,</p></li>
<li><p><u>stopień mutacji</u>: 10%,</p></li>
</ul>
<p>Otrzymane wykresy:</p>
<ul>
<li><p>Procent mutacji: 5%</p>
<ul>
<li><p>Funkcja celu: 184958.03</p>
<p><img src="images/Zrzut ekranu 2024-01-06 191051.png" class="img-fluid" width="554"></p></li>
</ul></li>
<li><p>Procent mutacji: 10%</p>
<ul>
<li><p>Funkcja celu: 197068.89</p>
<p><img src="images/Zrzut ekranu 2024-01-06 191128.png" class="img-fluid" width="554"></p></li>
</ul></li>
<li><p>Procent mutacji: 25%</p>
<ul>
<li><p>Funkcja celu: 170059.39</p>
<p><img src="images/Zrzut ekranu 2024-01-06 191158.png" class="img-fluid" width="554"></p></li>
</ul></li>
</ul>
<!-- -->
<ul>
<li><p>Procent mutacji: 50%</p>
<ul>
<li><p>Funkcja celu: 138087.16</p>
<p><img src="images/Zrzut ekranu 2024-01-06 191702.png" class="img-fluid" width="554"></p></li>
</ul></li>
</ul>
<p>Wniosek: Zwiększenie procentu mutacji pozytywnie wpływa na działanie algorytmu jedynie do czasu, ponieważ w pewnym momencie zmiany w każdej iteracji są zbyt duże. Zbyt duża liczba mutowanych osobników sprawia, że “gubimy” dobre rozwiązania i je zmieniamy.</p>
<p><strong>Test 8</strong></p>
<p>Autor: Szymon Pająk</p>
<p>Ostatnim parametrem, który został poddany badaniom był stopień mutacji w algorytmie, to znaczy jak bardzo osobnik z pokolenia ma zostać zmutowany. Pozostałe parametry prezentują się następująco:</p>
<ul>
<li><p><u>rozmiar populacji poczatkowej:</u> 40,</p></li>
<li><p><u>rozmiar pokolenia</u>: 30,</p></li>
<li><p><u>selekcja turniejowa</u></p></li>
<li><p><u>wielkość turnieju</u>: 10,</p></li>
<li><p><u>procent elity</u>: 5%,</p></li>
<li><p><u>rodzaj mutacji</u>: zmiana gospodarza,</p></li>
<li><p><u>procentowa ilość mutacji</u>: 10%,</p></li>
</ul>
<p>Otrzymane wykresy:</p>
<ul>
<li><p>Stopień mutacji: 5%</p>
<ul>
<li><p>Funkcja celu: 155456.05</p>
<p><img src="images/Zrzut ekranu 2024-01-06 173811.png" class="img-fluid" width="554"></p></li>
</ul></li>
<li><p>Stopień mutacji: 10%</p>
<ul>
<li><p>Funkcja celu: 177505.44</p>
<p><img src="images/Zrzut ekranu 2024-01-06 173854.png" class="img-fluid" width="554"></p></li>
</ul></li>
<li><p>Stopień mutacji: 25%</p>
<ul>
<li><p>Funkcja celu: 140462.74</p>
<p><img src="images/Zrzut ekranu 2024-01-06 173927.png" class="img-fluid" width="554"></p></li>
</ul></li>
</ul>
<p>Wniosek: Zwiększenie stopnia mutacji pozytywnie wpłynęło na działanie algorytmu, jednakże tylko do pewnego stopnia. Zbyt duże mutowanie danego osobnika sprawia, że wynik pogarsza się.</p>
<p>W naszych testach zajeliśmy się również badaniem złożoności czasowej oraz pamięciowej w zależności od wielkości populacji.</p>
<p>W pierwszej części zajeliśmy się badaniem złożoności pamięciowej sprawdziliśmy jak zachowuję się dla pokolenia od rozmiaru 20 do 90. Podstawowe parametry ustawiliśmy następująco:</p>
<ul>
<li><p>rozmiar pokolenia 30,</p></li>
<li><p>selekcję turniejową,</p></li>
<li><p>wielkość turnieju 10,</p></li>
<li><p>procent elity 5%,</p></li>
<li><p>rodzaj mutacji zmiana gospodarza,</p></li>
<li><p>procentowa ilość mutacji 10%,</p></li>
<li><p>stopień mutacji 10,</p></li>
</ul>
<p><img src="images/17-01.png" class="img-fluid" width="540"></p>
<p>W drugiej części zajeliśmy się badanie czasu na wielkość pokolenia, przy takich samych pozostałych wartościach pozostałych parametrów:</p>
<p><img src="images/18-03.png" class="img-fluid" width="540"></p>
<p>Wnioski: Zaobserwowaliśmy, że dla czas wykonania oraz zużycie pamięci jest zależne od wielkości pokolenia, im większe pokolenie tym większe zużycie pamięci oraz czasu.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>